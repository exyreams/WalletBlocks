{"ast":null,"code":"import _slicedToArray from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.mjs\";\nimport { notifyManager } from \"../core/index.mjs\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.mjs\";\nimport { useQueryClient } from \"./QueryClientProvider.mjs\";\nimport { shouldThrowError } from \"./utils.mjs\";\nimport { useIsRestoring } from \"./isRestoring.mjs\";\nexport function useBaseQuery(options, Observer) {\n  var queryClient = useQueryClient({\n    context: options.context\n  });\n  var isRestoring = useIsRestoring();\n  var errorResetBoundary = useQueryErrorResetBoundary();\n  var defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n  var _React$useState = React.useState(function () {\n      return new Observer(queryClient, defaultedOptions);\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 1),\n    observer = _React$useState2[0];\n  var result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(function (onStoreChange) {\n    return isRestoring ? function () {\n      return undefined;\n    } : observer.subscribe(notifyManager.batchCalls(onStoreChange));\n  }, [observer, isRestoring]), function () {\n    return observer.getCurrentResult();\n  }, function () {\n    return observer.getCurrentResult();\n  });\n  React.useEffect(function () {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n  React.useEffect(function () {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {\n    throw observer.fetchOptimistic(defaultedOptions).then(function (_ref) {\n      var data = _ref.data;\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(function (error) {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}","map":{"version":3,"names":["React","useSyncExternalStore","notifyManager","useQueryErrorResetBoundary","useQueryClient","shouldThrowError","useIsRestoring","useBaseQuery","options","Observer","queryClient","context","isRestoring","errorResetBoundary","defaultedOptions","defaultQueryOptions","_optimisticResults","onError","batchCalls","onSuccess","onSettled","suspense","staleTime","useErrorBoundary","isReset","retryOnMount","_React$useState","useState","_React$useState2","_slicedToArray","observer","result","getOptimisticResult","useCallback","onStoreChange","undefined","subscribe","getCurrentResult","useEffect","clearReset","setOptions","listeners","isLoading","isFetching","fetchOptimistic","then","_ref","data","catch","error","isError","getCurrentQuery","notifyOnChangeProps","trackResult"],"sources":["D:/Projects/RainbowKit/connectwallet/node_modules/react-query/lib/reactjs/useBaseQuery.mjs"],"sourcesContent":["import React from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.mjs\";\nimport { notifyManager } from \"../core/index.mjs\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.mjs\";\nimport { useQueryClient } from \"./QueryClientProvider.mjs\";\nimport { shouldThrowError } from \"./utils.mjs\";\nimport { useIsRestoring } from \"./isRestoring.mjs\";\nexport function useBaseQuery(options, Observer) {\n  const queryClient = useQueryClient({\n    context: options.context\n  });\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = queryClient.defaultQueryOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options\n\n  defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders\n\n  if (defaultedOptions.onError) {\n    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);\n  }\n\n  if (defaultedOptions.onSuccess) {\n    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);\n  }\n\n  if (defaultedOptions.onSettled) {\n    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);\n  }\n\n  if (defaultedOptions.suspense) {\n    // Always set stale time when using suspense to prevent\n    // fetching again when directly mounting after suspending\n    if (typeof defaultedOptions.staleTime !== 'number') {\n      defaultedOptions.staleTime = 1000;\n    }\n  }\n\n  if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {\n    // Prevent retrying failed query if the error boundary has not been reset yet\n    if (!errorResetBoundary.isReset()) {\n      defaultedOptions.retryOnMount = false;\n    }\n  }\n\n  const [observer] = React.useState(() => new Observer(queryClient, defaultedOptions));\n  const result = observer.getOptimisticResult(defaultedOptions);\n  useSyncExternalStore(React.useCallback(onStoreChange => isRestoring ? () => undefined : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n  React.useEffect(() => {\n    // Do not notify on updates because of changes in the options because\n    // these changes should already be reflected in the optimistic result.\n    observer.setOptions(defaultedOptions, {\n      listeners: false\n    });\n  }, [defaultedOptions, observer]); // Handle suspense\n\n  if (defaultedOptions.suspense && result.isLoading && result.isFetching && !isRestoring) {\n    throw observer.fetchOptimistic(defaultedOptions).then(({\n      data\n    }) => {\n      defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);\n    }).catch(error => {\n      errorResetBoundary.clearReset();\n      defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);\n      defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);\n    });\n  } // Handle error boundary\n\n\n  if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(defaultedOptions.useErrorBoundary, [result.error, observer.getCurrentQuery()])) {\n    throw result.error;\n  } // Handle result property usage tracking\n\n\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}