{"ast":null,"code":"import _objectSpread from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { getAbortController, noop, replaceData, timeUntilStale } from \"./utils.mjs\";\nimport { defaultLogger } from \"./logger.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { isCancelledError, canFetch, createRetryer } from \"./retryer.mjs\";\nimport { Removable } from \"./removable.mjs\"; // TYPES\n\n// CLASS\nexport var Query = /*#__PURE__*/function (_Removable) {\n  _inherits(Query, _Removable);\n  var _super = _createSuper(Query);\n  function Query(config) {\n    var _this;\n    _classCallCheck(this, Query);\n    _this = _super.call(this);\n    _this.abortSignalConsumed = false;\n    _this.defaultOptions = config.defaultOptions;\n    _this.setOptions(config.options);\n    _this.observers = [];\n    _this.cache = config.cache;\n    _this.logger = config.logger || defaultLogger;\n    _this.queryKey = config.queryKey;\n    _this.queryHash = config.queryHash;\n    _this.initialState = config.state || getDefaultState(_this.options);\n    _this.state = _this.initialState;\n    _this.meta = config.meta;\n    return _this;\n  }\n  _createClass(Query, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = _objectSpread(_objectSpread({}, this.defaultOptions), options);\n      this.meta = options == null ? void 0 : options.meta;\n      this.updateCacheTime(this.options.cacheTime);\n    }\n  }, {\n    key: \"optionalRemove\",\n    value: function optionalRemove() {\n      if (!this.observers.length && this.state.fetchStatus === 'idle') {\n        this.cache.remove(this);\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(newData, options) {\n      var data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n      this.dispatch({\n        data: data,\n        type: 'success',\n        dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n        manual: options == null ? void 0 : options.manual\n      });\n      return data;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(state, setStateOptions) {\n      this.dispatch({\n        type: 'setState',\n        state: state,\n        setStateOptions: setStateOptions\n      });\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(options) {\n      var _this$retryer;\n      var promise = this.promise;\n      (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n      return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      _get(_getPrototypeOf(Query.prototype), \"destroy\", this).call(this);\n      this.cancel({\n        silent: true\n      });\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.destroy();\n      this.setState(this.initialState);\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.observers.some(function (observer) {\n        return observer.options.enabled !== false;\n      });\n    }\n  }, {\n    key: \"isDisabled\",\n    value: function isDisabled() {\n      return this.getObserversCount() > 0 && !this.isActive();\n    }\n  }, {\n    key: \"isStale\",\n    value: function isStale() {\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(function (observer) {\n        return observer.getCurrentResult().isStale;\n      });\n    }\n  }, {\n    key: \"isStaleByTime\",\n    value: function isStaleByTime() {\n      var staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n    }\n  }, {\n    key: \"onFocus\",\n    value: function onFocus() {\n      var _this$retryer2;\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnWindowFocus();\n      });\n      if (observer) {\n        observer.refetch({\n          cancelRefetch: false\n        });\n      } // Continue fetch if currently paused\n\n      (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n    }\n  }, {\n    key: \"onOnline\",\n    value: function onOnline() {\n      var _this$retryer3;\n      var observer = this.observers.find(function (x) {\n        return x.shouldFetchOnReconnect();\n      });\n      if (observer) {\n        observer.refetch({\n          cancelRefetch: false\n        });\n      } // Continue fetch if currently paused\n\n      (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n    }\n  }, {\n    key: \"addObserver\",\n    value: function addObserver(observer) {\n      if (this.observers.indexOf(observer) === -1) {\n        this.observers.push(observer); // Stop the query from being garbage collected\n\n        this.clearGcTimeout();\n        this.cache.notify({\n          type: 'observerAdded',\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"removeObserver\",\n    value: function removeObserver(observer) {\n      if (this.observers.indexOf(observer) !== -1) {\n        this.observers = this.observers.filter(function (x) {\n          return x !== observer;\n        });\n        if (!this.observers.length) {\n          // If the transport layer does not support cancellation\n          // we'll let the query continue so the result can be cached\n          if (this.retryer) {\n            if (this.abortSignalConsumed) {\n              this.retryer.cancel({\n                revert: true\n              });\n            } else {\n              this.retryer.cancelRetry();\n            }\n          }\n          this.scheduleGc();\n        }\n        this.cache.notify({\n          type: 'observerRemoved',\n          query: this,\n          observer: observer\n        });\n      }\n    }\n  }, {\n    key: \"getObserversCount\",\n    value: function getObserversCount() {\n      return this.observers.length;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      if (!this.state.isInvalidated) {\n        this.dispatch({\n          type: 'invalidate'\n        });\n      }\n    }\n  }, {\n    key: \"fetch\",\n    value: function fetch(options, fetchOptions) {\n      var _this2 = this;\n      var _this$options$behavio, _context$fetchOptions;\n      if (this.state.fetchStatus !== 'idle') {\n        if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n          // Silently cancel current fetch if the user wants to cancel refetches\n          this.cancel({\n            silent: true\n          });\n        } else if (this.promise) {\n          var _this$retryer4;\n\n          // make sure that retries that were potentially cancelled due to unmounts can continue\n          (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n          return this.promise;\n        }\n      } // Update config if passed, otherwise the config from the last execution is used\n\n      if (options) {\n        this.setOptions(options);\n      } // Use the options from the first observer with a query function if no function is found.\n      // This can happen when the query is hydrated or created with setQueryData.\n\n      if (!this.options.queryFn) {\n        var observer = this.observers.find(function (x) {\n          return x.options.queryFn;\n        });\n        if (observer) {\n          this.setOptions(observer.options);\n        }\n      }\n      if (!Array.isArray(this.options.queryKey)) {\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n        }\n      }\n      var abortController = getAbortController(); // Create query function context\n\n      var queryFnContext = {\n        queryKey: this.queryKey,\n        pageParam: undefined,\n        meta: this.meta\n      }; // Adds an enumerable signal property to the object that\n      // which sets abortSignalConsumed to true when the signal\n      // is read.\n\n      var addSignalProperty = function addSignalProperty(object) {\n        Object.defineProperty(object, 'signal', {\n          enumerable: true,\n          get: function get() {\n            if (abortController) {\n              _this2.abortSignalConsumed = true;\n              return abortController.signal;\n            }\n            return undefined;\n          }\n        });\n      };\n      addSignalProperty(queryFnContext); // Create fetch function\n\n      var fetchFn = function fetchFn() {\n        if (!_this2.options.queryFn) {\n          return Promise.reject('Missing queryFn');\n        }\n        _this2.abortSignalConsumed = false;\n        return _this2.options.queryFn(queryFnContext);\n      }; // Trigger behavior hook\n\n      var context = {\n        fetchOptions: fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        state: this.state,\n        fetchFn: fetchFn,\n        meta: this.meta\n      };\n      addSignalProperty(context);\n      (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n      this.revertState = this.state; // Set to fetching state if not already in it\n\n      if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n        var _context$fetchOptions2;\n        this.dispatch({\n          type: 'fetch',\n          meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n        });\n      }\n      var onError = function onError(error) {\n        // Optimistically update state if needed\n        if (!(isCancelledError(error) && error.silent)) {\n          _this2.dispatch({\n            type: 'error',\n            error: error\n          });\n        }\n        if (!isCancelledError(error)) {\n          var _this$cache$config$on, _this$cache$config;\n\n          // Notify cache callback\n          (_this$cache$config$on = (_this$cache$config = _this2.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, _this2);\n          if (process.env.NODE_ENV !== 'production') {\n            _this2.logger.error(error);\n          }\n        }\n        if (!_this2.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          _this2.scheduleGc();\n        }\n        _this2.isFetchingOptimistic = false;\n      }; // Try to fetch the data\n\n      this.retryer = createRetryer({\n        fn: context.fetchFn,\n        abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n        onSuccess: function onSuccess(data) {\n          var _this$cache$config$on2, _this$cache$config2;\n          if (typeof data === 'undefined') {\n            onError(new Error('Query data cannot be undefined'));\n            return;\n          }\n          _this2.setData(data); // Notify cache callback\n\n          (_this$cache$config$on2 = (_this$cache$config2 = _this2.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, _this2);\n          if (!_this2.isFetchingOptimistic) {\n            // Schedule query gc after fetching\n            _this2.scheduleGc();\n          }\n          _this2.isFetchingOptimistic = false;\n        },\n        onError: onError,\n        onFail: function onFail() {\n          _this2.dispatch({\n            type: 'failed'\n          });\n        },\n        onPause: function onPause() {\n          _this2.dispatch({\n            type: 'pause'\n          });\n        },\n        onContinue: function onContinue() {\n          _this2.dispatch({\n            type: 'continue'\n          });\n        },\n        retry: context.options.retry,\n        retryDelay: context.options.retryDelay,\n        networkMode: context.options.networkMode\n      });\n      this.promise = this.retryer.promise;\n      return this.promise;\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(action) {\n      var _this3 = this;\n      var reducer = function reducer(state) {\n        var _action$meta, _action$dataUpdatedAt;\n        switch (action.type) {\n          case 'failed':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchFailureCount: state.fetchFailureCount + 1\n            });\n          case 'pause':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchStatus: 'paused'\n            });\n          case 'continue':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchStatus: 'fetching'\n            });\n          case 'fetch':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              fetchFailureCount: 0,\n              fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n              fetchStatus: canFetch(_this3.options.networkMode) ? 'fetching' : 'paused'\n            }, !state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            });\n          case 'success':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              data: action.data,\n              dataUpdateCount: state.dataUpdateCount + 1,\n              dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n              error: null,\n              isInvalidated: false,\n              status: 'success'\n            }, !action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            });\n          case 'error':\n            var error = action.error;\n            if (isCancelledError(error) && error.revert && _this3.revertState) {\n              return _objectSpread({}, _this3.revertState);\n            }\n            return _objectSpread(_objectSpread({}, state), {}, {\n              error: error,\n              errorUpdateCount: state.errorUpdateCount + 1,\n              errorUpdatedAt: Date.now(),\n              fetchFailureCount: state.fetchFailureCount + 1,\n              fetchStatus: 'idle',\n              status: 'error'\n            });\n          case 'invalidate':\n            return _objectSpread(_objectSpread({}, state), {}, {\n              isInvalidated: true\n            });\n          case 'setState':\n            return _objectSpread(_objectSpread({}, state), action.state);\n        }\n      };\n      this.state = reducer(this.state);\n      notifyManager.batch(function () {\n        _this3.observers.forEach(function (observer) {\n          observer.onQueryUpdate(action);\n        });\n        _this3.cache.notify({\n          query: _this3,\n          type: 'updated',\n          action: action\n        });\n      });\n    }\n  }]);\n  return Query;\n}(Removable);\nfunction getDefaultState(options) {\n  var data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  var hasInitialData = typeof options.initialData !== 'undefined';\n  var initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  var hasData = typeof data !== 'undefined';\n  return {\n    data: data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}","map":{"version":3,"names":["getAbortController","noop","replaceData","timeUntilStale","defaultLogger","notifyManager","isCancelledError","canFetch","createRetryer","Removable","Query","_Removable","_inherits","_super","_createSuper","config","_this","_classCallCheck","call","abortSignalConsumed","defaultOptions","setOptions","options","observers","cache","logger","queryKey","queryHash","initialState","state","getDefaultState","meta","_createClass","key","value","_objectSpread","updateCacheTime","cacheTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","dispatch","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","_this$retryer","promise","retryer","then","catch","Promise","resolve","destroy","_get","_getPrototypeOf","prototype","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","arguments","undefined","onFocus","_this$retryer2","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","_this$retryer3","shouldFetchOnReconnect","addObserver","indexOf","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","scheduleGc","invalidate","fetch","fetchOptions","_this2","_this$options$behavio","_context$fetchOptions","_this$retryer4","continueRetry","queryFn","Array","isArray","process","env","NODE_ENV","error","abortController","queryFnContext","pageParam","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","reject","context","behavior","onFetch","revertState","fetchMeta","_context$fetchOptions2","onError","_this$cache$config$on","_this$cache$config","isFetchingOptimistic","fn","abort","bind","onSuccess","_this$cache$config$on2","_this$cache$config2","Error","onFail","onPause","onContinue","retry","retryDelay","networkMode","action","_this3","reducer","_action$meta","_action$dataUpdatedAt","fetchFailureCount","status","dataUpdateCount","Date","now","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasInitialData","initialDataUpdatedAt","hasData"],"sources":["D:/Projects/RainbowKit/connectwallet/node_modules/react-query/lib/core/query.mjs"],"sourcesContent":["import { getAbortController, noop, replaceData, timeUntilStale } from \"./utils.mjs\";\nimport { defaultLogger } from \"./logger.mjs\";\nimport { notifyManager } from \"./notifyManager.mjs\";\nimport { isCancelledError, canFetch, createRetryer } from \"./retryer.mjs\";\nimport { Removable } from \"./removable.mjs\"; // TYPES\n\n// CLASS\nexport class Query extends Removable {\n  constructor(config) {\n    super();\n    this.abortSignalConsumed = false;\n    this.defaultOptions = config.defaultOptions;\n    this.setOptions(config.options);\n    this.observers = [];\n    this.cache = config.cache;\n    this.logger = config.logger || defaultLogger;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.initialState = config.state || getDefaultState(this.options);\n    this.state = this.initialState;\n    this.meta = config.meta;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.defaultOptions,\n      ...options\n    };\n    this.meta = options == null ? void 0 : options.meta;\n    this.updateCacheTime(this.options.cacheTime);\n  }\n\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.cache.remove(this);\n    }\n  }\n\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options); // Set data and mark it as cached\n\n    this.dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options == null ? void 0 : options.updatedAt,\n      manual: options == null ? void 0 : options.manual\n    });\n    return data;\n  }\n\n  setState(state, setStateOptions) {\n    this.dispatch({\n      type: 'setState',\n      state,\n      setStateOptions\n    });\n  }\n\n  cancel(options) {\n    var _this$retryer;\n\n    const promise = this.promise;\n    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n\n  reset() {\n    this.destroy();\n    this.setState(this.initialState);\n  }\n\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n\n  isStale() {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some(observer => observer.getCurrentResult().isStale);\n  }\n\n  isStaleByTime(staleTime = 0) {\n    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n\n  onFocus() {\n    var _this$retryer2;\n\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();\n  }\n\n  onOnline() {\n    var _this$retryer3;\n\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n\n    if (observer) {\n      observer.refetch({\n        cancelRefetch: false\n      });\n    } // Continue fetch if currently paused\n\n\n    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();\n  }\n\n  addObserver(observer) {\n    if (this.observers.indexOf(observer) === -1) {\n      this.observers.push(observer); // Stop the query from being garbage collected\n\n      this.clearGcTimeout();\n      this.cache.notify({\n        type: 'observerAdded',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  removeObserver(observer) {\n    if (this.observers.indexOf(observer) !== -1) {\n      this.observers = this.observers.filter(x => x !== observer);\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.retryer) {\n          if (this.abortSignalConsumed) {\n            this.retryer.cancel({\n              revert: true\n            });\n          } else {\n            this.retryer.cancelRetry();\n          }\n        }\n\n        this.scheduleGc();\n      }\n\n      this.cache.notify({\n        type: 'observerRemoved',\n        query: this,\n        observer\n      });\n    }\n  }\n\n  getObserversCount() {\n    return this.observers.length;\n  }\n\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: 'invalidate'\n      });\n    }\n  }\n\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetches\n        this.cancel({\n          silent: true\n        });\n      } else if (this.promise) {\n        var _this$retryer4;\n\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry(); // Return current promise if we are already fetching\n\n        return this.promise;\n      }\n    } // Update config if passed, otherwise the config from the last execution is used\n\n\n    if (options) {\n      this.setOptions(options);\n    } // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n\n\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n\n    if (!Array.isArray(this.options.queryKey)) {\n      if (process.env.NODE_ENV !== 'production') {\n        this.logger.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n\n    const abortController = getAbortController(); // Create query function context\n\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      pageParam: undefined,\n      meta: this.meta\n    }; // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n\n    const addSignalProperty = object => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          if (abortController) {\n            this.abortSignalConsumed = true;\n            return abortController.signal;\n          }\n\n          return undefined;\n        }\n      });\n    };\n\n    addSignalProperty(queryFnContext); // Create fetch function\n\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject('Missing queryFn');\n      }\n\n      this.abortSignalConsumed = false;\n      return this.options.queryFn(queryFnContext);\n    }; // Trigger behavior hook\n\n\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n      meta: this.meta\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context); // Store state in case the current fetch needs to be reverted\n\n    this.revertState = this.state; // Set to fetching state if not already in it\n\n    if (this.state.fetchStatus === 'idle' || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n\n      this.dispatch({\n        type: 'fetch',\n        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n\n    const onError = error => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.dispatch({\n          type: 'error',\n          error: error\n        });\n      }\n\n      if (!isCancelledError(error)) {\n        var _this$cache$config$on, _this$cache$config;\n\n        // Notify cache callback\n        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);\n\n        if (process.env.NODE_ENV !== 'production') {\n          this.logger.error(error);\n        }\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc();\n      }\n\n      this.isFetchingOptimistic = false;\n    }; // Try to fetch the data\n\n\n    this.retryer = createRetryer({\n      fn: context.fetchFn,\n      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _this$cache$config$on2, _this$cache$config2;\n\n        if (typeof data === 'undefined') {\n          onError(new Error('Query data cannot be undefined'));\n          return;\n        }\n\n        this.setData(data); // Notify cache callback\n\n        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, data, this);\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc();\n        }\n\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: () => {\n        this.dispatch({\n          type: 'failed'\n        });\n      },\n      onPause: () => {\n        this.dispatch({\n          type: 'pause'\n        });\n      },\n      onContinue: () => {\n        this.dispatch({\n          type: 'continue'\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode\n    });\n    this.promise = this.retryer.promise;\n    return this.promise;\n  }\n\n  dispatch(action) {\n    const reducer = state => {\n      var _action$meta, _action$dataUpdatedAt;\n\n      switch (action.type) {\n        case 'failed':\n          return { ...state,\n            fetchFailureCount: state.fetchFailureCount + 1\n          };\n\n        case 'pause':\n          return { ...state,\n            fetchStatus: 'paused'\n          };\n\n        case 'continue':\n          return { ...state,\n            fetchStatus: 'fetching'\n          };\n\n        case 'fetch':\n          return { ...state,\n            fetchFailureCount: 0,\n            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,\n            fetchStatus: canFetch(this.options.networkMode) ? 'fetching' : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'loading'\n            })\n          };\n\n        case 'success':\n          return { ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0\n            })\n          };\n\n        case 'error':\n          const error = action.error;\n\n          if (isCancelledError(error) && error.revert && this.revertState) {\n            return { ...this.revertState\n            };\n          }\n\n          return { ...state,\n            error: error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchStatus: 'idle',\n            status: 'error'\n          };\n\n        case 'invalidate':\n          return { ...state,\n            isInvalidated: true\n          };\n\n        case 'setState':\n          return { ...state,\n            ...action.state\n          };\n      }\n    };\n\n    this.state = reducer(this.state);\n    notifyManager.batch(() => {\n      this.observers.forEach(observer => {\n        observer.onQueryUpdate(action);\n      });\n      this.cache.notify({\n        query: this,\n        type: 'updated',\n        action\n      });\n    });\n  }\n\n}\n\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === 'function' ? options.initialData() : options.initialData;\n  const hasInitialData = typeof options.initialData !== 'undefined';\n  const initialDataUpdatedAt = hasInitialData ? typeof options.initialDataUpdatedAt === 'function' ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  const hasData = typeof data !== 'undefined';\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'loading',\n    fetchStatus: 'idle'\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}