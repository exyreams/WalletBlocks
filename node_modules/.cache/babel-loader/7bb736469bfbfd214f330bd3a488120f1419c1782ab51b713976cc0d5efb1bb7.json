{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nvar _defineProperty = require(\"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _classCallCheck = require(\"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"D:/Projects/RainbowKit/connectwallet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKConnection = void 0;\nvar rxjs_1 = require(\"rxjs\");\nvar operators_1 = require(\"rxjs/operators\");\nvar Session_1 = require(\"../relay/Session\");\nvar types_1 = require(\"../types\");\nvar ClientMessage_1 = require(\"./ClientMessage\");\nvar DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\nvar RxWebSocket_1 = require(\"./RxWebSocket\");\nvar ServerMessage_1 = require(\"./ServerMessage\");\nvar HEARTBEAT_INTERVAL = 10000;\nvar REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nvar WalletSDKConnection = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  function WalletSDKConnection(sessionId, sessionKey, linkAPIUrl, diagnostic) {\n    var _this = this;\n    var WebSocketClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : WebSocket;\n    _classCallCheck(this, WalletSDKConnection);\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.diagnostic = diagnostic;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, types_1.IntNumber)(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    var ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws;\n    // attempt to reconnect every 5 seconds when disconnected\n    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)(function (state) {\n      var _a;\n      return (_a = _this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n        state: state,\n        sessionIdHash: Session_1.Session.hash(sessionId)\n      });\n    }),\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1),\n    // if DISCONNECTED and not destroyed\n    (0, operators_1.filter)(function (cs) {\n      return cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !_this.destroyed;\n    }),\n    // wait 5 seconds\n    (0, operators_1.delay)(5000),\n    // check whether it's destroyed again\n    (0, operators_1.filter)(function (_) {\n      return !_this.destroyed;\n    }),\n    // reconnect\n    (0, operators_1.flatMap)(function (_) {\n      return ws.connect();\n    }), (0, operators_1.retry)()).subscribe());\n    // perform authentication upon connection\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED and CONNECTING states\n    (0, operators_1.skip)(2), (0, operators_1.switchMap)(function (cs) {\n      return (0, rxjs_1.iif)(function () {\n        return cs === RxWebSocket_1.ConnectionState.CONNECTED;\n      },\n      // if CONNECTED, authenticate, and then check link status\n      _this.authenticate().pipe((0, operators_1.tap)(function (_) {\n        return _this.sendIsLinked();\n      }), (0, operators_1.tap)(function (_) {\n        return _this.sendGetSessionConfig();\n      }), (0, operators_1.map)(function (_) {\n        return true;\n      })),\n      // if not CONNECTED, emit false immediately\n      (0, rxjs_1.of)(false));\n    }), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(function (_) {\n      return (0, rxjs_1.of)(false);\n    })).subscribe(function (connected) {\n      return _this.connectedSubject.next(connected);\n    }));\n    // send heartbeat every n seconds while connected\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), (0, operators_1.switchMap)(function (cs) {\n      return (0, rxjs_1.iif)(function () {\n        return cs === RxWebSocket_1.ConnectionState.CONNECTED;\n      },\n      // if CONNECTED, start the heartbeat timer\n      (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL));\n    })).subscribe(function (i) {\n      return (\n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? _this.updateLastHeartbeat() : _this.heartbeat()\n      );\n    }));\n    // handle server's heartbeat responses\n    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)(function (m) {\n      return m === \"h\";\n    })).subscribe(function (_) {\n      return _this.updateLastHeartbeat();\n    }));\n    // handle link status updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(function (m) {\n      return [\"IsLinkedOK\", \"Linked\"].includes(m.type);\n    })).subscribe(function (m) {\n      var _a;\n      var msg = m;\n      (_a = _this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        linked: msg.linked,\n        type: m.type,\n        onlineGuests: msg.onlineGuests\n      });\n      _this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    }));\n    // handle session config updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(function (m) {\n      return [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type);\n    })).subscribe(function (m) {\n      var _a;\n      var msg = m;\n      (_a = _this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n      });\n      _this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n  _createClass(WalletSDKConnection, [{\n    key: \"connect\",\n    value: function connect() {\n      var _a;\n      if (this.destroyed) {\n        throw new Error(\"instance is destroyed\");\n      }\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n        sessionIdHash: Session_1.Session.hash(this.sessionId)\n      });\n      this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _a;\n      this.subscriptions.unsubscribe();\n      this.ws.disconnect();\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n        sessionIdHash: Session_1.Session.hash(this.sessionId)\n      });\n      this.destroyed = true;\n    }\n  }, {\n    key: \"isDestroyed\",\n    get: function get() {\n      return this.destroyed;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n  }, {\n    key: \"connected$\",\n    get: function get() {\n      return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n  }, {\n    key: \"onceConnected$\",\n    get: function get() {\n      return this.connected$.pipe((0, operators_1.filter)(function (v) {\n        return v;\n      }), (0, operators_1.take)(1), (0, operators_1.map)(function () {\n        return void 0;\n      }));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n  }, {\n    key: \"linked$\",\n    get: function get() {\n      return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n  }, {\n    key: \"onceLinked$\",\n    get: function get() {\n      return this.linked$.pipe((0, operators_1.filter)(function (v) {\n        return v;\n      }), (0, operators_1.take)(1), (0, operators_1.map)(function () {\n        return void 0;\n      }));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n  }, {\n    key: \"sessionConfig$\",\n    get: function get() {\n      return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n  }, {\n    key: \"incomingEvent$\",\n    get: function get() {\n      return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(function (m) {\n        if (m.type !== \"Event\") {\n          return false;\n        }\n        var sme = m;\n        return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n      }), (0, operators_1.map)(function (m) {\n        return m;\n      }));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n  }, {\n    key: \"setSessionMetadata\",\n    value: function setSessionMetadata(key, value) {\n      var _this2 = this;\n      var message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId,\n        metadata: _defineProperty({}, key, value)\n      });\n      return this.onceConnected$.pipe((0, operators_1.flatMap)(function (_) {\n        return _this2.makeRequest(message);\n      }), (0, operators_1.map)(function (res) {\n        if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n          throw new Error(res.error || \"failed to set session metadata\");\n        }\n      }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n  }, {\n    key: \"publishEvent\",\n    value: function publishEvent(event, data) {\n      var _this3 = this;\n      var callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId,\n        event: event,\n        data: data,\n        callWebhook: callWebhook\n      });\n      return this.onceLinked$.pipe((0, operators_1.flatMap)(function (_) {\n        return _this3.makeRequest(message);\n      }), (0, operators_1.map)(function (res) {\n        if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n          throw new Error(res.error || \"failed to publish event\");\n        }\n        return res.eventId;\n      }));\n    }\n  }, {\n    key: \"sendData\",\n    value: function sendData(message) {\n      this.ws.sendData(JSON.stringify(message));\n    }\n  }, {\n    key: \"updateLastHeartbeat\",\n    value: function updateLastHeartbeat() {\n      this.lastHeartbeatResponse = Date.now();\n    }\n  }, {\n    key: \"heartbeat\",\n    value: function heartbeat() {\n      if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n        this.ws.disconnect();\n        return;\n      }\n      try {\n        this.ws.sendData(\"h\");\n      } catch (_a) {}\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(message) {\n      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : REQUEST_TIMEOUT;\n      var reqId = message.id;\n      try {\n        this.sendData(message);\n      } catch (err) {\n        return (0, rxjs_1.throwError)(err);\n      }\n      // await server message with corresponding id\n      return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(\"request \".concat(reqId, \" timed out\")))), (0, operators_1.filter)(function (m) {\n        return m.id === reqId;\n      }), (0, operators_1.take)(1));\n    }\n  }, {\n    key: \"authenticate\",\n    value: function authenticate() {\n      var msg = (0, ClientMessage_1.ClientMessageHostSession)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId,\n        sessionKey: this.sessionKey\n      });\n      return this.makeRequest(msg).pipe((0, operators_1.map)(function (res) {\n        if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n          throw new Error(res.error || \"failed to authentcate\");\n        }\n      }));\n    }\n  }, {\n    key: \"sendIsLinked\",\n    value: function sendIsLinked() {\n      var msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId\n      });\n      this.sendData(msg);\n    }\n  }, {\n    key: \"sendGetSessionConfig\",\n    value: function sendGetSessionConfig() {\n      var msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n        id: (0, types_1.IntNumber)(this.nextReqId++),\n        sessionId: this.sessionId\n      });\n      this.sendData(msg);\n    }\n  }]);\n  return WalletSDKConnection;\n}();\nexports.WalletSDKConnection = WalletSDKConnection;","map":{"version":3,"names":["_defineProperty","require","default","_classCallCheck","_createClass","Object","defineProperty","exports","value","WalletSDKConnection","rxjs_1","operators_1","Session_1","types_1","ClientMessage_1","DiagnosticLogger_1","RxWebSocket_1","ServerMessage_1","HEARTBEAT_INTERVAL","REQUEST_TIMEOUT","sessionId","sessionKey","linkAPIUrl","diagnostic","_this","WebSocketClass","arguments","length","undefined","WebSocket","subscriptions","Subscription","destroyed","lastHeartbeatResponse","nextReqId","IntNumber","connectedSubject","BehaviorSubject","linkedSubject","sessionConfigSubject","ReplaySubject","ws","RxWebSocket","add","connectionState$","pipe","tap","state","_a","log","EVENTS","CONNECTED_STATE_CHANGE","sessionIdHash","Session","hash","skip","filter","cs","ConnectionState","DISCONNECTED","delay","_","flatMap","connect","retry","subscribe","switchMap","iif","CONNECTED","authenticate","sendIsLinked","sendGetSessionConfig","map","of","distinctUntilChanged","catchError","connected","next","timer","i","updateLastHeartbeat","heartbeat","incomingData$","m","incomingJSONData$","includes","type","msg","LINKED","linked","onlineGuests","SESSION_CONFIG_RECEIVED","metadata_keys","metadata","keys","webhookId","webhookUrl","key","Error","STARTED_CONNECTING","destroy","unsubscribe","disconnect","get","asObservable","connected$","v","take","linked$","sme","eventId","event","data","setSessionMetadata","_this2","message","ClientMessageSetSessionConfig","id","onceConnected$","makeRequest","res","isServerMessageFail","error","publishEvent","_this3","callWebhook","ClientMessagePublishEvent","onceLinked$","sendData","JSON","stringify","Date","now","timeout","reqId","err","throwError","timeoutWith","concat","ClientMessageHostSession","ClientMessageIsLinked","ClientMessageGetSessionConfig"],"sources":["D:/Projects/RainbowKit/connectwallet/node_modules/@coinbase/wallet-sdk/dist/connection/WalletSDKConnection.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletSDKConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletSDKConnection {\n    /**\n     * Constructor\n     * @param sessionId Session ID\n     * @param sessionKey Session Key\n     * @param linkAPIUrl Coinbase Wallet link server URL\n     * @param [WebSocketClass] Custom WebSocket implementation\n     */\n    constructor(sessionId, sessionKey, linkAPIUrl, diagnostic, WebSocketClass = WebSocket) {\n        this.sessionId = sessionId;\n        this.sessionKey = sessionKey;\n        this.diagnostic = diagnostic;\n        this.subscriptions = new rxjs_1.Subscription();\n        this.destroyed = false;\n        this.lastHeartbeatResponse = 0;\n        this.nextReqId = (0, types_1.IntNumber)(1);\n        this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n        this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n        this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n        const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n        this.ws = ws;\n        // attempt to reconnect every 5 seconds when disconnected\n        this.subscriptions.add(ws.connectionState$\n            .pipe((0, operators_1.tap)(state => {\n            var _a;\n            return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n                state,\n                sessionIdHash: Session_1.Session.hash(sessionId),\n            });\n        }), \n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), \n        // if DISCONNECTED and not destroyed\n        (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), \n        // wait 5 seconds\n        (0, operators_1.delay)(5000), \n        // check whether it's destroyed again\n        (0, operators_1.filter)(_ => !this.destroyed), \n        // reconnect\n        (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)())\n            .subscribe());\n        // perform authentication upon connection\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED and CONNECTING states\n        (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, authenticate, and then check link status\n        this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)), \n        // if not CONNECTED, emit false immediately\n        (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false)))\n            .subscribe(connected => this.connectedSubject.next(connected)));\n        // send heartbeat every n seconds while connected\n        this.subscriptions.add(ws.connectionState$\n            .pipe(\n        // ignore initial DISCONNECTED state\n        (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, \n        // if CONNECTED, start the heartbeat timer\n        (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL))))\n            .subscribe(i => \n        // first timer event updates lastHeartbeat timestamp\n        // subsequent calls send heartbeat message\n        i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n        // handle server's heartbeat responses\n        this.subscriptions.add(ws.incomingData$\n            .pipe((0, operators_1.filter)(m => m === \"h\"))\n            .subscribe(_ => this.updateLastHeartbeat()));\n        // handle link status updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                linked: msg.linked,\n                type: m.type,\n                onlineGuests: msg.onlineGuests,\n            });\n            this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n        }));\n        // handle session config updates\n        this.subscriptions.add(ws.incomingJSONData$\n            .pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type)))\n            .subscribe(m => {\n            var _a;\n            const msg = m;\n            (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n                sessionIdHash: Session_1.Session.hash(sessionId),\n                metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined,\n            });\n            this.sessionConfigSubject.next({\n                webhookId: msg.webhookId,\n                webhookUrl: msg.webhookUrl,\n                metadata: msg.metadata,\n            });\n        }));\n    }\n    /**\n     * Make a connection to the server\n     */\n    connect() {\n        var _a;\n        if (this.destroyed) {\n            throw new Error(\"instance is destroyed\");\n        }\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.ws.connect().subscribe();\n    }\n    /**\n     * Terminate connection, and mark as destroyed. To reconnect, create a new\n     * instance of WalletSDKConnection\n     */\n    destroy() {\n        var _a;\n        this.subscriptions.unsubscribe();\n        this.ws.disconnect();\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n            sessionIdHash: Session_1.Session.hash(this.sessionId),\n        });\n        this.destroyed = true;\n    }\n    get isDestroyed() {\n        return this.destroyed;\n    }\n    /**\n     * Emit true if connected and authenticated, else false\n     * @returns an Observable\n     */\n    get connected$() {\n        return this.connectedSubject.asObservable();\n    }\n    /**\n     * Emit once connected\n     * @returns an Observable\n     */\n    get onceConnected$() {\n        return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit true if linked (a guest has joined before)\n     * @returns an Observable\n     */\n    get linked$() {\n        return this.linkedSubject.asObservable();\n    }\n    /**\n     * Emit once when linked\n     * @returns an Observable\n     */\n    get onceLinked$() {\n        return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n    }\n    /**\n     * Emit current session config if available, and subsequent updates\n     * @returns an Observable for the session config\n     */\n    get sessionConfig$() {\n        return this.sessionConfigSubject.asObservable();\n    }\n    /**\n     * Emit incoming Event messages\n     * @returns an Observable for the messages\n     */\n    get incomingEvent$() {\n        return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n            if (m.type !== \"Event\") {\n                return false;\n            }\n            const sme = m;\n            return (typeof sme.sessionId === \"string\" &&\n                typeof sme.eventId === \"string\" &&\n                typeof sme.event === \"string\" &&\n                typeof sme.data === \"string\");\n        }), (0, operators_1.map)(m => m));\n    }\n    /**\n     * Set session metadata in SessionConfig object\n     * @param key\n     * @param value\n     * @returns an Observable that completes when successful\n     */\n    setSessionMetadata(key, value) {\n        const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            metadata: { [key]: value },\n        });\n        return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to set session metadata\");\n            }\n        }));\n    }\n    /**\n     * Publish an event and emit event ID when successful\n     * @param event event name\n     * @param data event data\n     * @param callWebhook whether the webhook should be invoked\n     * @returns an Observable that emits event ID when successful\n     */\n    publishEvent(event, data, callWebhook = false) {\n        const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            event,\n            data,\n            callWebhook,\n        });\n        return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to publish event\");\n            }\n            return res.eventId;\n        }));\n    }\n    sendData(message) {\n        this.ws.sendData(JSON.stringify(message));\n    }\n    updateLastHeartbeat() {\n        this.lastHeartbeatResponse = Date.now();\n    }\n    heartbeat() {\n        if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n            this.ws.disconnect();\n            return;\n        }\n        try {\n            this.ws.sendData(\"h\");\n        }\n        catch (_a) { }\n    }\n    makeRequest(message, timeout = REQUEST_TIMEOUT) {\n        const reqId = message.id;\n        try {\n            this.sendData(message);\n        }\n        catch (err) {\n            return (0, rxjs_1.throwError)(err);\n        }\n        // await server message with corresponding id\n        return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n    }\n    authenticate() {\n        const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n            sessionKey: this.sessionKey,\n        });\n        return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n            if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n                throw new Error(res.error || \"failed to authentcate\");\n            }\n        }));\n    }\n    sendIsLinked() {\n        const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n    sendGetSessionConfig() {\n        const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n            id: (0, types_1.IntNumber)(this.nextReqId++),\n            sessionId: this.sessionId,\n        });\n        this.sendData(msg);\n    }\n}\nexports.WalletSDKConnection = WalletSDKConnection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}